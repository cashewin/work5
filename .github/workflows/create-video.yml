name: üé¨ Create Video (Optimized)

on:
  repository_dispatch:
    types: [create_video]

jobs:
  create-video:
    runs-on: ubuntu-latest

    container:
      image: docker.io/cashewin/video-tools:latest
      credentials:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
      options: --user 0

    defaults:
      run:
        shell: bash

    steps:
      - name: üßæ Checkout repository
        uses: actions/checkout@v4

      - name: üì¶ Prepare assets from payload (PARALLEL DOWNLOADS)
        run: |
          set -euo pipefail
          mkdir -p assets output /tmp

          echo "================================================"
          echo "üé¨ VIDEO CREATION STARTING (9:16 Vertical) - OPTIMIZED"
          echo "================================================"

          echo '${{ toJson(github.event.client_payload.images) }}' > /tmp/images.json

          # Parallel image downloads using background processes
          idx=0
          pids=()
          while IFS= read -r image_url; do
            if [ -n "$image_url" ] && [ "$image_url" != "null" ]; then
              outfile="assets/image_$(printf '%03d' "$idx").png"
              echo "üì• Starting download $((idx + 1)): $image_url"
              (curl -L --fail --retry 2 --connect-timeout 10 -o "$outfile" "$image_url" && echo "‚úÖ Downloaded image $((idx + 1))") &
              pids+=($!)
              idx=$((idx + 1))
            fi
          done < <(jq -r '.[]?' /tmp/images.json)

          # Download voiceover in parallel
          if [ -n "${{ github.event.client_payload.voiceover_url || '' }}" ]; then
            echo "üé§ Starting voiceover download..."
            (curl -L --fail --retry 2 --connect-timeout 10 --retry-delay 1 -o assets/voiceover_raw "${{ github.event.client_payload.voiceover_url }}" && echo "‚úÖ Voiceover downloaded") &
            pids+=($!)
          fi

          # Download background music in parallel
          if [ -n "${{ github.event.client_payload.background_music_url || '' }}" ]; then
            echo "üéµ Starting background music download..."
            (curl -L --fail --retry 2 --connect-timeout 10 --retry-delay 1 -o assets/bgmusic.mp3 "${{ github.event.client_payload.background_music_url }}" && echo "‚úÖ Background music downloaded") &
            pids+=($!)
          fi

          # Wait for all parallel downloads to complete
          echo "‚è≥ Waiting for all downloads to complete..."
          for pid in "${pids[@]}"; do
            wait $pid || echo "‚ö†Ô∏è Download process $pid failed"
          done

          echo "üìä Total images: $idx"
          ls -lh assets/

          # Process voiceover if exists
          if [ -f assets/voiceover_raw ]; then
            if ffprobe -v error -select_streams a -show_entries stream=codec_name -of csv=p=0 assets/voiceover_raw >/dev/null 2>&1; then
              mv assets/voiceover_raw assets/voiceover.mp3
              echo "‚úÖ Audio file ready (already encoded)"
            else
              echo "üîÑ Converting PCM to MP3..."
              ffmpeg -y -f s16le -ar 24000 -ac 1 -i assets/voiceover_raw \
                -c:a libmp3lame -b:a 128k -ar 48000 \
                assets/voiceover.mp3
              rm assets/voiceover_raw
              echo "‚úÖ PCM to MP3 conversion complete"
            fi
            
            # Quick validation
            VO_DUR=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 assets/voiceover.mp3 2>/dev/null)
            if [[ "$VO_DUR" =~ ^[0-9]+\.?[0-9]*$ ]] && (( $(echo "$VO_DUR > 0.1" | bc -l) )); then
              echo "‚úÖ Audio validated: ${VO_DUR}s"
            else
              echo "‚ö†Ô∏è Invalid audio, removing"
              rm -f assets/voiceover.mp3
            fi
          fi

      - name: üìù Save subtitle text
        if: github.event.client_payload.subtitle_text != '' && github.event.client_payload.subtitle_text != null
        run: |
          cat > /tmp/subtitle_text.txt <<'EOF'
          ${{ github.event.client_payload.subtitle_text }}
          EOF

      - name: üéûÔ∏è Create vertical video (9:16) - SINGLE-PASS OPTIMIZED
        run: |
          set -euo pipefail
          
          echo "================================================"
          echo "üé• VIDEO CREATION - OPTIMIZED SINGLE-PASS"
          echo "================================================"
          
          # Get voiceover duration
          DURATION=30
          if [ -f assets/voiceover.mp3 ]; then
            RAW_DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 assets/voiceover.mp3)
            if [[ "$RAW_DURATION" =~ ^[0-9]+\.?[0-9]*$ ]] && [ -n "$RAW_DURATION" ]; then
              DURATION=$(printf "%.0f" "$RAW_DURATION")
              echo "üé§ Detected voiceover duration: ${DURATION}s"
            fi
          fi
          
          IMG_COUNT=$(ls -1 assets/image_*.png 2>/dev/null | wc -l)
          if [ "$IMG_COUNT" -eq 0 ]; then
            echo "‚ùå No images found!"
            exit 1
          fi
          
          TRANSITION_DURATION=0.5
          DURATION_PER_IMAGE=$(echo "scale=2; ($DURATION + ($IMG_COUNT - 1) * $TRANSITION_DURATION) / $IMG_COUNT" | bc)
          
          echo "üìä Images: $IMG_COUNT | Duration: ${DURATION}s | Per-image: ${DURATION_PER_IMAGE}s"

          # Build optimized filter with lower FPS for faster processing
          FILTER_COMPLEX=""
          
          for i in $(seq 0 $((IMG_COUNT - 1))); do
            FILTER_COMPLEX="${FILTER_COMPLEX}[${i}:v]scale=1080:1920:force_original_aspect_ratio=increase,crop=1080:1920,setsar=1,fps=30,zoompan=z='min(zoom+0.0015,1.05)':d=${DURATION_PER_IMAGE}*30:s=1080x1920:fps=30[v${i}];"
          done
          
          FILTER_COMPLEX="${FILTER_COMPLEX}[v0]"
          for i in $(seq 1 $((IMG_COUNT - 1))); do
            OFFSET=$(echo "scale=2; $i * ($DURATION_PER_IMAGE - $TRANSITION_DURATION)" | bc)
            FILTER_COMPLEX="${FILTER_COMPLEX}[v${i}]xfade=transition=fade:duration=${TRANSITION_DURATION}:offset=${OFFSET}"
            if [ $i -lt $((IMG_COUNT - 1)) ]; then
              FILTER_COMPLEX="${FILTER_COMPLEX}[vt${i}];[vt${i}]"
            fi
          done
          FILTER_COMPLEX="${FILTER_COMPLEX}[vout]"

          INPUTS=""
          for i in $(seq 0 $((IMG_COUNT - 1))); do
            INPUTS="$INPUTS -i assets/image_$(printf '%03d' $i).png"
          done

          echo "üé¨ Creating base video with ultrafast preset..."
          ffmpeg -y $INPUTS -filter_complex "$FILTER_COMPLEX" -map "[vout]" \
            -c:v libx264 -pix_fmt yuv420p -preset ultrafast -crf 23 \
            -movflags +faststart -t $DURATION \
            output/base.mp4

          echo "‚úÖ Base video created"

          # Prepare subtitle filter if needed
          SUBTITLE_FILTER=""
          if [ -f /tmp/subtitle_text.txt ]; then
            echo "üìù Generating subtitles..."
            SUBTITLE_TEXT=$(cat /tmp/subtitle_text.txt)
            WORD_COUNT=$(echo "$SUBTITLE_TEXT" | wc -w)
            
            if [ "$WORD_COUNT" -gt 0 ]; then
              SECONDS_PER_WORD=$(echo "scale=4; $DURATION / $WORD_COUNT" | bc)
              
              > output/subs.srt
              WORDS=($SUBTITLE_TEXT)
              SUBTITLE_NUM=1
              CURRENT_TIME=0
              WORDS_PER_SUBTITLE=5
              
              for ((i=0; i<${#WORDS[@]}; i+=WORDS_PER_SUBTITLE)); do
                CHUNK="${WORDS[@]:i:WORDS_PER_SUBTITLE}"
                CHUNK_WORD_COUNT=$(echo "$CHUNK" | wc -w)
                START_TIME=$CURRENT_TIME
                CHUNK_DURATION=$(echo "scale=4; $CHUNK_WORD_COUNT * $SECONDS_PER_WORD" | bc)
                END_TIME=$(echo "scale=4; $START_TIME + $CHUNK_DURATION" | bc)
                
                format_time() {
                  local seconds=$1
                  local h=$(echo "$seconds / 3600" | bc)
                  local m=$(echo "($seconds % 3600) / 60" | bc)
                  local s=$(echo "$seconds % 60" | bc)
                  local int_s=${s%.*}
                  local ms=$(echo "($s - $int_s) * 1000" | bc)
                  printf "%02d:%02d:%02d,%03d" ${h:-0} ${m:-0} ${int_s:-0} ${ms%.*}
                }
                
                echo "$SUBTITLE_NUM" >> output/subs.srt
                echo "$(format_time $START_TIME) --> $(format_time $END_TIME)" >> output/subs.srt
                echo "$CHUNK" >> output/subs.srt
                echo "" >> output/subs.srt
                
                SUBTITLE_NUM=$((SUBTITLE_NUM + 1))
                CURRENT_TIME=$END_TIME
              done
              
              SUBTITLE_FILTER=",subtitles=output/subs.srt:force_style='FontName=Noto Sans,Bold=1,FontSize=12,PrimaryColour=&HFFFFFF&,OutlineColour=&H000000&,BackColour=&H80000000&,BorderStyle=4,Outline=2,Shadow=0,MarginV=45,Alignment=2'"
              echo "‚úÖ Subtitles prepared"
            fi
          fi

          # Build single-pass complex filter for video + audio
          OUTPUT_NAME="${{ github.event.client_payload.output_name || 'output.mp4' }}"
          
          # Determine audio inputs and filters
          AUDIO_INPUTS=""
          AUDIO_FILTER=""
          HAS_VOICEOVER=false
          HAS_BGMUSIC=false
          
          if [ -f assets/voiceover.mp3 ]; then
            AUDIO_INPUTS="$AUDIO_INPUTS -i assets/voiceover.mp3"
            HAS_VOICEOVER=true
          fi
          
          if [ -f assets/bgmusic.mp3 ]; then
            AUDIO_INPUTS="$AUDIO_INPUTS -i assets/bgmusic.mp3"
            HAS_BGMUSIC=true
          fi

          # SINGLE-PASS: Combine video processing + subtitle + audio mixing
          if [ "$HAS_VOICEOVER" = true ] && [ "$HAS_BGMUSIC" = true ]; then
            # Both voiceover and background music
            echo "üéµ Single-pass: Video + Subtitles + Voiceover + Background Music"
            
            # Determine input indices (base video is 0)
            VO_IDX=1
            BG_IDX=2
            
            ffmpeg -y -i output/base.mp4 $AUDIO_INPUTS \
              -filter_complex "[0:v]null${SUBTITLE_FILTER}[vout];[${BG_IDX}:a]volume=0.2,aloop=loop=-1:size=2e9[bg];[${VO_IDX}:a][bg]amix=inputs=2:duration=first:dropout_transition=2[aout]" \
              -map "[vout]" -map "[aout]" \
              -c:v libx264 -preset veryfast -crf 23 \
              -c:a aac -b:a 128k \
              -movflags +faststart \
              "output/$OUTPUT_NAME"
              
          elif [ "$HAS_VOICEOVER" = true ]; then
            # Only voiceover
            echo "üé§ Single-pass: Video + Subtitles + Voiceover"
            
            ffmpeg -y -i output/base.mp4 -i assets/voiceover.mp3 \
              -filter_complex "[0:v]null${SUBTITLE_FILTER}[vout]" \
              -map "[vout]" -map 1:a \
              -c:v libx264 -preset veryfast -crf 23 \
              -c:a aac -b:a 128k \
              -movflags +faststart \
              "output/$OUTPUT_NAME"
              
          elif [ "$HAS_BGMUSIC" = true ]; then
            # Only background music
            echo "üéµ Single-pass: Video + Subtitles + Background Music"
            
            ffmpeg -y -i output/base.mp4 -i assets/bgmusic.mp3 \
              -filter_complex "[0:v]null${SUBTITLE_FILTER}[vout];[1:a]volume=0.4,aloop=loop=-1:size=2e9[aout]" \
              -map "[vout]" -map "[aout]" \
              -c:v libx264 -preset veryfast -crf 23 \
              -c:a aac -b:a 128k \
              -movflags +faststart \
              "output/$OUTPUT_NAME"
              
          else
            # No audio - just video with subtitles
            echo "üé¨ Single-pass: Video + Subtitles"
            
            if [ -n "$SUBTITLE_FILTER" ]; then
              ffmpeg -y -i output/base.mp4 \
                -vf "null${SUBTITLE_FILTER}" \
                -c:v libx264 -preset veryfast -crf 23 \
                -movflags +faststart \
                "output/$OUTPUT_NAME"
            else
              # No subtitles either, just copy
              mv output/base.mp4 "output/$OUTPUT_NAME"
            fi
          fi

          # Cleanup temp file
          rm -f output/base.mp4

          echo "================================================"
          echo "‚úÖ VIDEO CREATED SUCCESSFULLY (OPTIMIZED)!"
          echo "================================================"
          ls -lh "output/$OUTPUT_NAME"
          
          FINAL_DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "output/$OUTPUT_NAME" 2>/dev/null || echo "unknown")
          if [[ "$FINAL_DURATION" =~ ^[0-9]+\.?[0-9]*$ ]]; then
            echo "‚è±Ô∏è  Duration: $(printf "%.1f" "$FINAL_DURATION")s"
          fi
          echo "üìê Resolution: 1080x1920 (9:16)"
          echo "üì¶ Size: $(ls -lh "output/$OUTPUT_NAME" | awk '{print $5}')"

      - name: üé® Apply watermark (if enabled)
        if: github.event.client_payload.watermark_enabled == 'true' || github.event.client_payload.watermark_enabled == true
        run: |
          set -euo pipefail
          
          echo "üé® Applying watermark..."
          
          OUTPUT_NAME="${{ github.event.client_payload.output_name || 'output.mp4' }}"
          INPUT_VIDEO="output/$OUTPUT_NAME"
          WATERMARKED_VIDEO="output/${OUTPUT_NAME%.mp4}_watermarked.mp4"
          
          WATERMARK_TYPE="${{ github.event.client_payload.watermark_type || 'text' }}"
          WATERMARK_POSITION="${{ github.event.client_payload.watermark_position || 'bottom-right' }}"
          WATERMARK_OPACITY="${{ github.event.client_payload.watermark_opacity || '70' }}"
          
          if [ "$WATERMARK_TYPE" = "text" ]; then
            WATERMARK_TEXT="${{ github.event.client_payload.watermark_text || 'YourBrand' }}"
            WATERMARK_FONTSIZE="${{ github.event.client_payload.watermark_fontsize || '48' }}"
            WATERMARK_COLOR="${{ github.event.client_payload.watermark_color || '#FFFFFF' }}"
            
            FFMPEG_COLOR="0x${WATERMARK_COLOR#\#}"
            OPACITY=$(echo "scale=2; $WATERMARK_OPACITY / 100" | bc)
            
            case "$WATERMARK_POSITION" in
              "top-left") X_POS="20"; Y_POS="20" ;;
              "top-right") X_POS="(w-text_w-20)"; Y_POS="20" ;;
              "bottom-left") X_POS="20"; Y_POS="(h-text_h-20)" ;;
              "bottom-right") X_POS="(w-text_w-20)"; Y_POS="(h-text_h-20)" ;;
              "center") X_POS="(w-text_w)/2"; Y_POS="(h-text_h)/2" ;;
              *) X_POS="(w-text_w-20)"; Y_POS="(h-text_h-20)" ;;
            esac
            
            ESCAPED_TEXT=$(echo "$WATERMARK_TEXT" | sed "s/'/\\\\'/g" | sed "s/:/\\\\:/g")
            
            ffmpeg -y -i "$INPUT_VIDEO" \
              -vf "drawtext=text='${ESCAPED_TEXT}':fontsize=${WATERMARK_FONTSIZE}:fontcolor=${FFMPEG_COLOR}@${OPACITY}:x=${X_POS}:y=${Y_POS}" \
              -c:a copy -preset veryfast \
              -movflags +faststart \
              "$WATERMARKED_VIDEO"
              
          elif [ "$WATERMARK_TYPE" = "image" ]; then
            WATERMARK_URL="${{ github.event.client_payload.watermark_image_url }}"
            WATERMARK_SCALE="${{ github.event.client_payload.watermark_scale || '20' }}"
            
            if [ -z "$WATERMARK_URL" ]; then
              echo "‚ùå Image watermark URL not provided"
              exit 1
            fi
            
            curl -L --fail --retry 2 -o assets/watermark.png "$WATERMARK_URL"
            
            OPACITY=$(echo "scale=2; $WATERMARK_OPACITY / 100" | bc)
            SCALE_PERCENT=$(echo "scale=2; $WATERMARK_SCALE / 100" | bc)
            
            case "$WATERMARK_POSITION" in
              "top-left") OVERLAY_POS="20:20" ;;
              "top-right") OVERLAY_POS="W-w-20:20" ;;
              "bottom-left") OVERLAY_POS="20:H-h-20" ;;
              "bottom-right") OVERLAY_POS="W-w-20:H-h-20" ;;
              "center") OVERLAY_POS="(W-w)/2:(H-h)/2" ;;
              *) OVERLAY_POS="W-w-20:H-h-20" ;;
            esac
            
            ffmpeg -y -i "$INPUT_VIDEO" -i assets/watermark.png \
              -filter_complex "[1:v]scale=iw*${SCALE_PERCENT}:ih*${SCALE_PERCENT},format=rgba,colorchannelmixer=aa=${OPACITY}[wm];[0:v][wm]overlay=${OVERLAY_POS}" \
              -c:a copy -preset veryfast \
              -movflags +faststart \
              "$WATERMARKED_VIDEO"
          fi
          
          mv "$WATERMARKED_VIDEO" "$INPUT_VIDEO"
          echo "‚úÖ Watermark applied"

      - name: üì§ Upload video to backend
        run: |
          set -euo pipefail
          
          OUTPUT_NAME="${{ github.event.client_payload.output_name || 'output.mp4' }}"
          WEBHOOK_URL="${{ github.event.client_payload.callback_url }}"
          JOB_ID="${{ github.event.client_payload.job_id }}"
          WEBHOOK_SECRET="${{ github.event.client_payload.webhook_secret }}"
          
          if [ ! -f "output/$OUTPUT_NAME" ]; then
            echo "‚ùå Video file not found: output/$OUTPUT_NAME"
            
            curl -X POST "$WEBHOOK_URL" \
              -F "status=failed" \
              -F "job_id=$JOB_ID" \
              -F "webhook_secret=$WEBHOOK_SECRET" \
              -F "run_id=${{ github.run_id }}" \
              -F "error=Video file not found after processing"
            exit 1
          fi
          
          VIDEO_SIZE=$(stat -f%z "output/$OUTPUT_NAME" 2>/dev/null || stat -c%s "output/$OUTPUT_NAME")
          echo "üì¶ Video size: $((VIDEO_SIZE / 1024 / 1024)) MB"
          
          echo "üì§ Uploading video to: $WEBHOOK_URL"
          
          HTTP_CODE=$(curl -w "%{http_code}" -X POST "$WEBHOOK_URL" \
            -F "video=@output/$OUTPUT_NAME" \
            -F "status=success" \
            -F "job_id=$JOB_ID" \
            -F "webhook_secret=$WEBHOOK_SECRET" \
            -F "run_id=${{ github.run_id }}" \
            -o /tmp/upload_response.txt)
          
          echo "üìä Upload response code: $HTTP_CODE"
          cat /tmp/upload_response.txt
          
          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "‚úÖ Video uploaded successfully!"
          else
            echo "‚ùå Upload failed with code: $HTTP_CODE"
            exit 1
          fi
