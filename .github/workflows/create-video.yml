name: üé¨ Create Video

on:
  repository_dispatch:
    types: [create_video]

jobs:
  create-video:
    runs-on: ubuntu-latest

    container:
      image: docker.io/cashewin/video-tools:latest
      credentials:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
      options: --user 0

    defaults:
      run:
        shell: bash

    steps:
      - name: üßæ Checkout repository
        uses: actions/checkout@v4

      - name: üì¶ Prepare assets from payload
        run: |
          set -euo pipefail
          mkdir -p assets output /tmp

          echo "================================================"
          echo "üé¨ VIDEO CREATION STARTING (9:16 Vertical)"
          echo "================================================"

          echo '${{ toJson(github.event.client_payload.images) }}' > /tmp/images.json

          idx=0
          while IFS= read -r image_url; do
            if [ -n "$image_url" ] && [ "$image_url" != "null" ]; then
              outfile="assets/image_$(printf '%03d' "$idx").png"
              echo "üì• Downloading image $((idx + 1)): $image_url"
              curl -L --fail --retry 3 -o "$outfile" "$image_url"
              idx=$((idx + 1))
            fi
          done < <(jq -r '.[]?' /tmp/images.json)

          echo "üìä Total images: $idx"
          ls -lh assets/

          # ==========================================
          # IMPROVED PCM TO MP3 CONVERSION
          # ==========================================
          if [ -n "${{ github.event.client_payload.voiceover_url || '' }}" ]; then
            echo "üé§ Downloading voiceover..."
            curl -L --fail --retry 3 --retry-delay 2 -o assets/voiceover_raw "${{ github.event.client_payload.voiceover_url }}"
            
            if [ -f assets/voiceover_raw ]; then
              size=$(wc -c < assets/voiceover_raw)
              echo "‚úÖ Voiceover downloaded (${size} bytes)"
              
              if [ "$size" -gt 0 ]; then
                # Check if the file is already encoded audio using ffprobe
                codec_info=$(ffprobe -v error -select_streams a:0 -show_entries stream=codec_name -of default=nk=1:nw=1 assets/voiceover_raw 2>/dev/null || echo "")
                
                if [ -z "$codec_info" ] || [ "$codec_info" = "none" ]; then
                  # No audio stream detected - likely raw PCM from Gemini TTS
                  echo "üîç No audio codec detected - treating as raw PCM"
                  echo "üîÑ Converting PCM (16-bit signed LE, 24kHz, mono) to MP3..."
                  echo "   Input size: ${size} bytes"
                  echo "   Expected duration: ~$(echo "scale=1; $size / 48000" | bc)s"
                  
                  # PCM format from Gemini TTS: s16le (signed 16-bit little-endian), 24000 Hz, mono
                  # Output: MP3 at 192kbps, 48000 Hz, stereo for better compatibility
                  echo "üéµ Running FFmpeg PCM to MP3 conversion..."
                  if ffmpeg -f s16le -ar 24000 -ac 1 -i assets/voiceover_raw \
                      -c:a libmp3lame -b:a 192k -ar 48000 -ac 2 \
                      -y -hide_banner assets/voiceover.mp3 2>&1 | tee /tmp/ffmpeg_convert.log; then
                    
                    # Validate the conversion
                    if [ -f assets/voiceover.mp3 ] && [ -s assets/voiceover.mp3 ]; then
                      converted_size=$(wc -c < assets/voiceover.mp3)
                      echo "‚úÖ PCM converted to MP3 (${converted_size} bytes)"
                      
                      # Verify audio is valid
                      audio_streams=$(ffprobe -v error -select_streams a -show_entries stream=codec_type -of csv=p=0 assets/voiceover.mp3 2>/dev/null | wc -l)
                      audio_duration=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 assets/voiceover.mp3 2>/dev/null || echo "0")
                      
                      echo "   Audio streams: $audio_streams"
                      echo "   Duration: ${audio_duration}s"
                      
                      # Accept any valid duration > 0.05s
                      if [ "$audio_streams" -gt 0 ] && [[ "$audio_duration" =~ ^[0-9]+\.?[0-9]*$ ]] && (( $(echo "$audio_duration > 0.05" | bc -l) )); then
                        rm -f assets/voiceover_raw
                        echo "‚úÖ PCM conversion verified successfully"
                        echo "üìä Voiceover details:"
                        ffprobe -v error -show_entries format=duration:stream=codec_name,sample_rate,channels,bit_rate -of default=noprint_wrappers=1 assets/voiceover.mp3 2>/dev/null || echo "   (details unavailable)"
                      else
                        echo "‚ùå Converted audio validation failed"
                        echo "   Streams: $audio_streams, Duration: $audio_duration"
                        echo "FFmpeg log:"
                        cat /tmp/ffmpeg_convert.log || echo "(no log)"
                        rm -f assets/voiceover.mp3 assets/voiceover_raw
                      fi
                    else
                      echo "‚ùå MP3 file not created or is empty"
                      echo "FFmpeg log:"
                      cat /tmp/ffmpeg_convert.log || echo "(no log)"
                      rm -f assets/voiceover_raw assets/voiceover.mp3
                    fi
                  else
                    FFMPEG_EXIT=$?
                    echo "‚ùå FFmpeg PCM conversion failed with exit code $FFMPEG_EXIT"
                    echo "FFmpeg log:"
                    cat /tmp/ffmpeg_convert.log || echo "(no log)"
                    rm -f assets/voiceover_raw assets/voiceover.mp3
                  fi
                else
                  # Already encoded (MP3, AAC, WAV, etc.) - just rename
                  echo "üìã Detected audio codec: $codec_info"
                  if [ "$codec_info" = "mp3" ]; then
                    mv assets/voiceover_raw assets/voiceover.mp3
                    echo "‚úÖ Audio file ready (already MP3)"
                  else
                    # Other audio format - transcode to MP3
                    echo "üîÑ Transcoding $codec_info to MP3..."
                    ffmpeg -y -i assets/voiceover_raw \
                      -c:a libmp3lame -b:a 192k -ar 48000 \
                      assets/voiceover.mp3 2>&1 | tee /tmp/ffmpeg_transcode.log
                    
                    if [ -f assets/voiceover.mp3 ] && [ -s assets/voiceover.mp3 ]; then
                      converted_size=$(wc -c < assets/voiceover.mp3)
                      echo "‚úÖ Transcoded to MP3 (${converted_size} bytes)"
                      rm -f assets/voiceover_raw
                    else
                      echo "‚ùå Failed to transcode to MP3"
                      cat /tmp/ffmpeg_transcode.log || echo "(no log)"
                      rm -f assets/voiceover_raw
                    fi
                  fi
                fi
                
                # Final validation of audio file
                if [ -f assets/voiceover.mp3 ]; then
                  echo "üîç Final validation of audio file..."
                  VO_STREAMS=$(ffprobe -v error -select_streams a -show_entries stream=codec_type -of csv=p=0 assets/voiceover.mp3 2>/dev/null | wc -l)
                  VO_DUR=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 assets/voiceover.mp3 2>/dev/null || echo "0")
                  
                  if [ $VO_STREAMS -eq 0 ]; then
                    echo "‚ùå Voiceover file has no audio streams!"
                    rm -f assets/voiceover.mp3
                  elif ! [[ "$VO_DUR" =~ ^[0-9]+\.?[0-9]*$ ]] || [ -z "$VO_DUR" ]; then
                    echo "‚ùå Voiceover has invalid duration: $VO_DUR"
                    rm -f assets/voiceover.mp3
                  elif (( $(echo "$VO_DUR < 0.1" | bc -l) )); then
                    echo "‚ùå Voiceover duration too short: ${VO_DUR}s"
                    rm -f assets/voiceover.mp3
                  else
                    echo "‚úÖ Audio validation passed: ${VO_DUR}s duration"
                  fi
                fi
              else
                echo "‚ö†Ô∏è  Voiceover file is empty (0 bytes)"
                rm -f assets/voiceover_raw
              fi
            else
              echo "‚ö†Ô∏è  Failed to download voiceover"
            fi
          fi

          if [ -n "${{ github.event.client_payload.background_music_url || '' }}" ]; then
            echo "üéµ Downloading background music..."
            curl -L --fail --retry 3 --retry-delay 2 -o assets/bgmusic.mp3 "${{ github.event.client_payload.background_music_url }}"
          fi

      - name: üìù Save subtitle text
        if: github.event.client_payload.subtitle_text != '' && github.event.client_payload.subtitle_text != null
        run: |
          cat > /tmp/subtitle_text.txt <<'EOF'
          ${{ github.event.client_payload.subtitle_text }}
          EOF

      - name: üéûÔ∏è Create vertical video (9:16) for Instagram Reels / YouTube Shorts
        run: |
          set -euo pipefail
          
          echo "================================================"
          echo "üé• VIDEO CREATION - VERTICAL FORMAT (1080x1920)"
          echo "================================================"
          
          # Get actual voiceover duration for proper video length
          DURATION=30
          if [ -f assets/voiceover.mp3 ]; then
            RAW_DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 assets/voiceover.mp3)
            # Check if duration is a valid number (not N/A or empty)
            if [[ "$RAW_DURATION" =~ ^[0-9]+\.?[0-9]*$ ]] && [ -n "$RAW_DURATION" ]; then
              DURATION=$(printf "%.0f" "$RAW_DURATION")
              echo "üé§ Detected voiceover duration: ${DURATION}s"
            else
              echo "‚ö†Ô∏è  Could not detect voiceover duration (got: $RAW_DURATION), using default: ${DURATION}s"
            fi
          else
            echo "‚è±Ô∏è  Using default duration: ${DURATION}s"
          fi
          
          # Fix image dimensions to 1080x1920 (9:16 vertical)
          mkdir -p fixed
          for img in assets/image_*.png; do
            if [ -f "$img" ]; then
              # Scale to fit 1080x1920 (cover the entire frame, cropping if needed)
              ffmpeg -y -i "$img" \
                -vf "scale=1080:1920:force_original_aspect_ratio=increase,crop=1080:1920" \
                "fixed/$(basename "$img")"
            fi
          done

          IMG_COUNT=$(ls -1 fixed/image_*.png 2>/dev/null | wc -l)
          
          if [ "$IMG_COUNT" -eq 0 ]; then
            echo "‚ùå No images found to process!"
            exit 1
          fi
          
          # Calculate per-image duration and transitions
          TRANSITION_DURATION=0.5
          DURATION_PER_IMAGE=$(echo "scale=2; ($DURATION + ($IMG_COUNT - 1) * $TRANSITION_DURATION) / $IMG_COUNT" | bc)
          
          echo "üìä Images: $IMG_COUNT"
          echo "üìê Resolution: 1080x1920 (9:16)"
          echo "‚è±Ô∏è  Total duration: ${DURATION}s"
          echo "üé¨ Duration per image: ${DURATION_PER_IMAGE}s"
          echo "üîÄ Transition: ${TRANSITION_DURATION}s"

          # Build complex filter for smooth transitions and zoom
          FILTER_COMPLEX=""
          
          # First, scale and add zoom effect to each image (vertical format)
          for i in $(seq 0 $((IMG_COUNT - 1))); do
            FILTER_COMPLEX="${FILTER_COMPLEX}[${i}:v]scale=1080:1920:force_original_aspect_ratio=increase,crop=1080:1920,setsar=1,fps=30,zoompan=z='min(zoom+0.0015,1.05)':d=${DURATION_PER_IMAGE}*30:s=1080x1920:fps=30[v${i}];"
          done
          
          # Add crossfade transitions between images
          FILTER_COMPLEX="${FILTER_COMPLEX}[v0]"
          for i in $(seq 1 $((IMG_COUNT - 1))); do
            OFFSET=$(echo "scale=2; $i * ($DURATION_PER_IMAGE - $TRANSITION_DURATION)" | bc)
            FILTER_COMPLEX="${FILTER_COMPLEX}[v${i}]xfade=transition=fade:duration=${TRANSITION_DURATION}:offset=${OFFSET}"
            if [ $i -lt $((IMG_COUNT - 1)) ]; then
              FILTER_COMPLEX="${FILTER_COMPLEX}[vt${i}];[vt${i}]"
            fi
          done
          FILTER_COMPLEX="${FILTER_COMPLEX}[vout]"

          # Build input string with proper paths
          INPUTS=""
          for i in $(seq 0 $((IMG_COUNT - 1))); do
            INPUTS="$INPUTS -i fixed/image_$(printf '%03d' $i).png"
          done

          echo "üé¨ Creating vertical slideshow with smooth transitions and zoom..."
          ffmpeg -y $INPUTS -filter_complex "$FILTER_COMPLEX" -map "[vout]" \
            -c:v libx264 -pix_fmt yuv420p -preset medium -crf 23 \
            -movflags +faststart -t $DURATION \
            output/temp.mp4

          echo "‚úÖ Base vertical video created"

          # Generate subtitles with perfect audio sync if subtitle text is provided
          if [ -f /tmp/subtitle_text.txt ]; then
            echo "üìù Generating movie-quality subtitles with perfect audio sync..."
            SUBTITLE_TEXT=$(cat /tmp/subtitle_text.txt)
            
            # Split text into words for timing calculation
            WORD_COUNT=$(echo "$SUBTITLE_TEXT" | wc -w)
            
            if [ "$WORD_COUNT" -gt 0 ]; then
              # Calculate precise timing - each word gets equal time based on total duration
              SECONDS_PER_WORD=$(echo "scale=4; $DURATION / $WORD_COUNT" | bc)
              
              echo "üìä Words: $WORD_COUNT | Rate: ${SECONDS_PER_WORD}s/word"
              
              # Generate SRT file with 4-6 words per subtitle (prevents overflow, perfect for vertical video)
              > output/subs.srt
              WORDS=($SUBTITLE_TEXT)
              SUBTITLE_NUM=1
              CURRENT_TIME=0
              WORDS_PER_SUBTITLE=5
              
              for ((i=0; i<${#WORDS[@]}; i+=WORDS_PER_SUBTITLE)); do
                # Get chunk of words
                CHUNK="${WORDS[@]:i:WORDS_PER_SUBTITLE}"
                CHUNK_WORD_COUNT=$(echo "$CHUNK" | wc -w)
                
                # Calculate precise timing for this chunk
                START_TIME=$CURRENT_TIME
                CHUNK_DURATION=$(echo "scale=4; $CHUNK_WORD_COUNT * $SECONDS_PER_WORD" | bc)
                END_TIME=$(echo "scale=4; $START_TIME + $CHUNK_DURATION" | bc)
                
                # Format times to SRT format (HH:MM:SS,mmm) with high precision
                format_time() {
                  local seconds=$1
                  local h=$(echo "$seconds / 3600" | bc)
                  local m=$(echo "($seconds % 3600) / 60" | bc)
                  local s=$(echo "$seconds % 60" | bc)
                  local int_s=${s%.*}
                  local ms=$(echo "($s - $int_s) * 1000" | bc)
                  printf "%02d:%02d:%02d,%03d" ${h:-0} ${m:-0} ${int_s:-0} ${ms%.*}
                }
                
                # Write SRT entry with precise timing
                echo "$SUBTITLE_NUM" >> output/subs.srt
                echo "$(format_time $START_TIME) --> $(format_time $END_TIME)" >> output/subs.srt
                echo "$CHUNK" >> output/subs.srt
                echo "" >> output/subs.srt
                
                SUBTITLE_NUM=$((SUBTITLE_NUM + 1))
                CURRENT_TIME=$END_TIME
              done
              
              echo "‚úÖ Subtitle file created with $((SUBTITLE_NUM - 1)) entries (perfectly synced)"
              
              # Check if video has audio stream to avoid time_base errors
              HAS_AUDIO_SUB=$(ffprobe -v error -select_streams a -show_entries stream=codec_type -of csv=p=0 output/temp.mp4 2>/dev/null | wc -l)
              
              # Apply MULTILINGUAL subtitles for supported languages
              # Using Noto Sans Bold which supports all 6 application languages
              # English, Hindi (‡§π‡§ø‡§®‡•ç‡§¶‡•Ä), Spanish, French, German, Russian (–†—É—Å—Å–∫–∏–π)
              # Alignment=2 (bottom-center) with MarginV=45 for proper bottom placement
              if [ $HAS_AUDIO_SUB -gt 0 ]; then
                # Video has audio, copy it
                ffmpeg -y -i output/temp.mp4 \
                  -vf "subtitles=output/subs.srt:force_style='FontName=Noto Sans,Bold=1,FontSize=12,PrimaryColour=&HFFFFFF&,OutlineColour=&H000000&,BackColour=&H80000000&,BorderStyle=4,Outline=2,Shadow=0,MarginV=45,Alignment=2'" \
                  -c:a copy -c:v libx264 -preset medium -crf 23 output/temp_subs.mp4
              else
                # Video has no audio yet, don't try to copy audio stream
                ffmpeg -y -i output/temp.mp4 \
                  -vf "subtitles=output/subs.srt:force_style='FontName=Noto Sans,Bold=1,FontSize=12,PrimaryColour=&HFFFFFF&,OutlineColour=&H000000&,BackColour=&H80000000&,BorderStyle=4,Outline=2,Shadow=0,MarginV=45,Alignment=2'" \
                  -c:v libx264 -preset medium -crf 23 output/temp_subs.mp4
              fi
              mv output/temp_subs.mp4 output/temp.mp4
              echo "‚úÖ Multilingual subtitles applied for: English, Hindi, Spanish, French, German, Russian"
            fi
          fi

          # Add voiceover if exists
          if [ -f assets/voiceover.mp3 ]; then
            echo "üé§ Validating and adding voiceover..."
            
            # Validate voiceover audio has valid streams and duration
            VO_AUDIO_STREAMS=$(ffprobe -v error -select_streams a -show_entries stream=codec_type -of csv=p=0 assets/voiceover.mp3 2>/dev/null | wc -l)
            VO_DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 assets/voiceover.mp3 2>/dev/null || echo "0")
            
            if [ $VO_AUDIO_STREAMS -eq 0 ]; then
              echo "‚ö†Ô∏è  Voiceover file has no audio streams - skipping"
            elif ! [[ "$VO_DURATION" =~ ^[0-9]+\.?[0-9]*$ ]] || [ -z "$VO_DURATION" ]; then
              echo "‚ö†Ô∏è  Voiceover has invalid duration ($VO_DURATION) - skipping"
            elif (( $(echo "$VO_DURATION < 0.1" | bc -l) )); then
              echo "‚ö†Ô∏è  Voiceover duration too short (${VO_DURATION}s) - skipping"
            else
              echo "‚úÖ Voiceover validated: ${VO_DURATION}s duration"
              
              # Re-encode voiceover to ensure clean AAC format with proper metadata
              echo "üîß Re-encoding voiceover for compatibility..."
              ffmpeg -y -i assets/voiceover.mp3 \
                -c:a aac -b:a 192k -ar 48000 -ac 2 \
                assets/voiceover_clean.aac
              
              # Validate the re-encoded AAC file
              AAC_STREAMS=$(ffprobe -v error -select_streams a -show_entries stream=codec_type -of csv=p=0 assets/voiceover_clean.aac 2>/dev/null | wc -l)
              AAC_DUR=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 assets/voiceover_clean.aac 2>/dev/null || echo "0")
              
              if [ $AAC_STREAMS -eq 0 ] || ! [[ "$AAC_DUR" =~ ^[0-9]+\.?[0-9]*$ ]] || (( $(echo "$AAC_DUR < 0.1" | bc -l) )); then
                echo "‚ùå Re-encoded AAC is invalid (streams: $AAC_STREAMS, duration: $AAC_DUR)"
              else
                echo "‚úÖ Re-encoded AAC validated: ${AAC_DUR}s"
                
                # Now add the clean voiceover to video
                ffmpeg -y -i output/temp.mp4 -i assets/voiceover_clean.aac \
                  -map 0:v -map 1:a \
                  -c:v copy -c:a copy \
                  -movflags +faststart \
                  output/temp_vo.mp4
                mv output/temp_vo.mp4 output/temp.mp4
                echo "‚úÖ Voiceover added"
              fi
            fi
          fi

          # Add background music with proper mixing
          if [ -f assets/bgmusic.mp3 ]; then
            echo "üéµ Validating and adding background music..."
            
            # Validate background music has valid streams and duration
            BG_AUDIO_STREAMS=$(ffprobe -v error -select_streams a -show_entries stream=codec_type -of csv=p=0 assets/bgmusic.mp3 2>/dev/null | wc -l)
            BG_DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 assets/bgmusic.mp3 2>/dev/null || echo "0")
            
            if [ $BG_AUDIO_STREAMS -eq 0 ]; then
              echo "‚ö†Ô∏è  Background music has no audio streams - skipping"
            elif ! [[ "$BG_DURATION" =~ ^[0-9]+\.?[0-9]*$ ]] || [ -z "$BG_DURATION" ]; then
              echo "‚ö†Ô∏è  Background music has invalid duration ($BG_DURATION) - skipping"
            elif (( $(echo "$BG_DURATION < 0.1" | bc -l) )); then
              echo "‚ö†Ô∏è  Background music duration too short (${BG_DURATION}s) - skipping"
            else
              echo "‚úÖ Background music validated: ${BG_DURATION}s duration"
              
              # Re-encode background music to ensure clean AAC format
              echo "üîß Re-encoding background music for compatibility..."
              ffmpeg -y -i assets/bgmusic.mp3 \
                -c:a aac -b:a 192k -ar 48000 -ac 2 \
                assets/bgmusic_clean.aac
              
              # Validate the re-encoded AAC file
              BG_AAC_STREAMS=$(ffprobe -v error -select_streams a -show_entries stream=codec_type -of csv=p=0 assets/bgmusic_clean.aac 2>/dev/null | wc -l)
              BG_AAC_DUR=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 assets/bgmusic_clean.aac 2>/dev/null || echo "0")
              
              if [ $BG_AAC_STREAMS -eq 0 ] || ! [[ "$BG_AAC_DUR" =~ ^[0-9]+\.?[0-9]*$ ]] || (( $(echo "$BG_AAC_DUR < 0.1" | bc -l) )); then
                echo "‚ùå Re-encoded background music AAC is invalid (streams: $BG_AAC_STREAMS, duration: $BG_AAC_DUR)"
              else
                echo "‚úÖ Re-encoded background music validated: ${BG_AAC_DUR}s"
                
                HAS_AUDIO=$(ffprobe -v error -select_streams a -show_entries stream=codec_type -of csv=p=0 output/temp.mp4 2>/dev/null | wc -l)
                
                if [ $HAS_AUDIO -gt 0 ]; then
                  # Mix: 80% voiceover + 20% background music
                  ffmpeg -y -i output/temp.mp4 -i assets/bgmusic_clean.aac \
                    -filter_complex "[1:a]volume=0.2[bg];[0:a][bg]amix=inputs=2:duration=first:dropout_transition=2[a]" \
                    -map 0:v -map "[a]" -c:v copy -c:a aac -b:a 192k \
                    -movflags +faststart \
                    output/temp_music.mp4
                else
                  # Just add background music at 40%
                  ffmpeg -y -i output/temp.mp4 -i assets/bgmusic_clean.aac \
                    -filter_complex "[1:a]volume=0.4[a]" \
                    -map 0:v -map "[a]" -c:v copy -c:a aac -b:a 192k \
                    -movflags +faststart \
                    output/temp_music.mp4
                fi
                
                if [ -f output/temp_music.mp4 ] && [ -s output/temp_music.mp4 ]; then
                  mv output/temp_music.mp4 output/temp.mp4
                  echo "‚úÖ Background music added"
                fi
              fi
            fi
          fi

          # Final output with optimization
          OUTPUT_NAME=${{ github.event.client_payload.output_name || 'output.mp4' }}
          
          # Check if video has audio for final encoding
          HAS_AUDIO_FINAL=$(ffprobe -v error -select_streams a -show_entries stream=codec_type -of csv=p=0 output/temp.mp4 2>/dev/null | wc -l)
          if [ $HAS_AUDIO_FINAL -gt 0 ]; then
            # Video has audio
            ffmpeg -y -i output/temp.mp4 \
              -c:v libx264 -preset medium -crf 23 \
              -c:a aac -b:a 192k \
              -movflags +faststart \
              "output/$OUTPUT_NAME"
          else
            # Video has no audio (video-only)
            ffmpeg -y -i output/temp.mp4 \
              -c:v libx264 -preset medium -crf 23 \
              -movflags +faststart \
              "output/$OUTPUT_NAME"
          fi

          echo "================================================"
          echo "‚úÖ VERTICAL VIDEO CREATED SUCCESSFULLY!"
          echo "================================================"
          ls -lh "output/$OUTPUT_NAME"
          
          # Show final video info
          echo ""
          echo "üìä Final Video Info:"
          FINAL_DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "output/$OUTPUT_NAME" 2>/dev/null || echo "unknown")
          if [[ "$FINAL_DURATION" =~ ^[0-9]+\.?[0-9]*$ ]]; then
            FINAL_DURATION_ROUNDED=$(printf "%.1f" "$FINAL_DURATION")
            echo "‚è±Ô∏è  Duration: ${FINAL_DURATION_ROUNDED}s"
          else
            echo "‚è±Ô∏è  Duration: ${FINAL_DURATION}"
          fi
          echo "üìê Resolution: 1080x1920 (9:16 vertical)"
          FINAL_SIZE=$(ls -lh "output/$OUTPUT_NAME" | awk '{print $5}')
          echo "üì¶ Size: $FINAL_SIZE"

      - name: üì§ Upload video to backend via webhook
        if: success() && github.event.client_payload.callback_url != '' && github.event.client_payload.callback_url != null
        run: |
          echo "================================================"
          echo "üì§ UPLOADING VIDEO TO BACKEND"
          echo "================================================"
          
          OUTPUT_NAME=${{ github.event.client_payload.output_name || 'output.mp4' }}
          VIDEO_FILE="output/$OUTPUT_NAME"
          CALLBACK_URL="${{ github.event.client_payload.callback_url }}"
          JOB_ID="${{ github.event.client_payload.job_id }}"
          
          if [ ! -f "$VIDEO_FILE" ]; then
            echo "‚ùå Video file not found: $VIDEO_FILE"
            exit 1
          fi
          
          VIDEO_SIZE=$(wc -c < "$VIDEO_FILE")
          VIDEO_SIZE_MB=$(echo "scale=2; $VIDEO_SIZE / 1024 / 1024" | bc)
          
          echo "üì¶ File: $VIDEO_FILE"
          echo "üìä Size: ${VIDEO_SIZE_MB} MB"
          echo "üîó Webhook URL: $CALLBACK_URL"
          echo "üÜî Job ID: $JOB_ID"
          echo "üîê Run ID: ${{ github.run_id }}"
          echo ""
          
          echo "üì° Uploading video with multipart/form-data..."
          
          RESPONSE=$(curl -X POST "$CALLBACK_URL" \
            -F "video=@$VIDEO_FILE" \
            -F "status=success" \
            -F "run_id=${{ github.run_id }}" \
            -F "job_id=$JOB_ID" \
            -F "webhook_secret=${{ secrets.WEBHOOK_SECRET }}" \
            --max-time 120 \
            --retry 3 \
            --retry-delay 5 \
            -w "\nüìä HTTP Status: %{http_code}\n" \
            -s)
          
          echo "$RESPONSE"
          
          # Check if upload was successful
          if echo "$RESPONSE" | grep -q '"message":"Webhook processed successfully"'; then
            echo "‚úÖ Video uploaded successfully!"
          else
            echo "‚ö†Ô∏è  Upload response: $RESPONSE"
            echo "‚ùå Video upload may have failed - check backend logs"
          fi

      - name: üì§ Upload video as artifact (fallback)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: video-output
          path: output/*.mp4
          retention-days: 7
